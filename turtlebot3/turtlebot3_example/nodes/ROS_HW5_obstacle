import rospy        # rospy를 import하여 ROS 기반에서 파이썬을 사용가능하게 한다.
import math       # 수학공식을 사용하기 위해 math를 import 한다.
from math import pi 
from sensor_msgs.msg import LaserScan       # lidar 센서 데이터를 subscribe하기 위해 메세지 형식과 패키지를 import한다.
from geometry_msgs.msg import Twist

WALL_PERCEPTION = 0.8   # 벽을 인식하는 거리를 1.0으로 정의한다.
LINEAR_VEL = 0.12                   # 선형 속도를 0.22m/s로 정의하는 구간으로, linear.x에 담겨 publish될 수치이다.
ANGULAR_VEL = 0.3
STOP_DISTANCE = 0.2                 # 정지 하기위한 거리를 나타내는 수치로, 0.2m로 정의한다.
LIDAR_ERROR = 0.05                  # lidar에서 발생하는 오차를 0.05m로 설정한다.
SAFE_STOP_DISTANCE = STOP_DISTANCE + LIDAR_ERROR        # lidar 데이터 오차를 대비하여 안전 정지 거리를 정의한다.

class Obstacle():
    def __init__(self):     # obstacle class를 정의한다.
        self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)     # publisher를 정의해주고, 토픽명, 메세지 타입, 큐사이즈를 설정한다.
        self.obstacle()     # 생성자 함수를 호출한다.
        
    def get_scan(self):      # lidar data에서 direction에 따라 scan filter에 담을 데이터를 저장하고, 반환해주는 함수이다.
        scan = rospy.wait_for_message('scan', LaserScan)    # subscriber를 설정해주는 구간으로, 토픽명과 메세지 타입을 설정한다.
        scan_filter = []    # 빈 행렬을 정의한다.

        scan_filter.extend(scan.ranges)  # scan_filter 행렬 끝에 scan 행렬의 0번에 해당하는 원소를 추가한다.

        for i in range(len(scan_filter)):       # scan_filter의 원소 개수만큼 i를 1씩 증가하여 아래의 구문을 반복 실행한다.  
            if scan_filter[i] == float('Inf'):  # 만약, 센서값이 infinity일 경우, 아래의 구문을 실행한다.
               scan_filter[i] = 3.5             # 해당 센서값을 최대값 3.5m로 설정한다.
            elif math.isnan(scan_filter[i]):    # 만약, 센서값이 none 값일 경우, 아래의 구문을 실행한다.
               scan_filter[i] = 0               # 해당 센서값을 최소값 0m로 설정한다.

        return scan_filter      # scan_filter 행렬을 반환한다.

    def obstacle(self):         # lidar 센서값(물체와의 거리)으로 판단하고 행동하는 역할을 수행하는 함수이다.
        twist = Twist()                 # Twist 형식의 메세지 변수를 정의한다.
        right_wall_find = False         # 현재 turtlebot의 움직임 상태를 나타내는 변수로, 현재 움직임이 있다는 True로 정의한다.
        right_wall_closest = False
        right_turn = False
        right_turn_allow1 = False
        right_turn_allow2 = False
        distances = []

        while not rospy.is_shutdown():                      # ROS가 구동하는 동안 무한으로 구동하는 반복문이다.
            distances.extend(self.get_scan())
            rospy.loginfo("\nfront : %f\nleft: %f\nback: %f\nright: %f",distances[0], distances[90], distances[180], distances[270])
            rospy.loginfo("\nfind: %s, closest: %s right: %s\nallow1: %s allow2: %s", right_wall_find, right_wall_closest, right_turn, right_turn_allow1, right_turn_allow2)
            
            if right_turn:
                if right_turn_allow2:
                    if distances[270] > WALL_PERCEPTION:
                        twist.linear.x = LINEAR_VEL      # x축 선형 속도를 정의한 속도로 정의한다.
                        twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다.
                        right_turn = True         # turtlebot이 움직이고 있음을 정의한다.
                        right_turn_allow2 = True
                    else:
                        twist.linear.x = 0.0      # x축 선형 속도를 정의한 속도로 정의한다.
                        twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다.
                        right_turn = False         # turtlebot이 움직이고 있음을 정의한다.
                        right_turn_allow1 = False 
                        right_turn_allow2 = False
                else:    
                    if right_turn_allow1:
                        if distances[305] > distances[325]:
                            twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                            twist.angular.z = -ANGULAR_VEL        # z축 각속도를 0.0으로 정의한다.
                            right_turn = True         # turtlebot이 움직이고 있음을 정의한다.
                            right_turn_allow1 = True # turtlebot
                        else:
                            twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                            twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다.
                            right_turn = True         # turtlebot이 움직이고 있음을 정의한다.
                            right_turn_allow2 = True
                    else:
                        if min(distances) != distances[225]:
                            twist.linear.x = LINEAR_VEL      # x축 선형 속도를 정의한 속도로 정의한다.
                            twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다.
                            right_turn = True         # turtlebot이 움직이고 있음을 정의한다.
                            right_wall_find = False 
                        else:
                            twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                            twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다
                            right_turn = True
                            right_turn_allow1 = True
            else:
                if right_wall_find:
                    if distances[0] > WALL_PERCEPTION :
                        if distances[285] > (WALL_PERCEPTION / math.cos(15/180*pi)) + 0.2:
                            twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                            twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다
                            right_turn = True
                            right_wall_find = False 
                        else:
                            if distances[270] <= WALL_PERCEPTION:
                                twist.linear.x = LINEAR_VEL       # x축 선형 속도를 정의한 속도로 정의한다.
                                twist.angular.z = (distances[255]-distances[285]) * 2.0         # z축 각속도를 0.0으로 정의한다.
                                right_wall_find = True           # turtlebot이 움직이고 있음을 정의한다.
                            else:
                                twist.linear.x = 0.0      # x축 선형 속도를 정의한 속도로 정의한다.
                                twist.angular.z = 0.0      # z축 각속도를 0.0으로 정의한다.
                                right_turn = True
                                right_wall_find = False          # turtlebot이 움직이고 있음을 정의한다.
                    else: 
                        twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                        twist.angular.z = ANGULAR_VEL        # z축 각속도를 0.0으로 정의한다.
                        right_wall_find = False
             
                elif right_wall_closest: 
                    if distances[285] < distances[255]: 
                        twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                        twist.angular.z = ANGULAR_VEL        # z축 각속도를 0.0으로 정의한다.
                        right_wall_find = False           # turtlebot이 움직이고 있음을 정의한다.
                    else:
                        twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                        twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다.
                        right_wall_find = True 
                else:
                    if distances[0] > WALL_PERCEPTION :
                        twist.linear.x = LINEAR_VEL       # x축 선형 속도를 정의한 속도로 정의한다.
                        twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다.
                        right_wall_find = False           # turtlebot이 움직이고 있음을 정의한다.
                        right_wall_closest = False
                    else:
                        twist.linear.x = 0.0       # x축 선형 속도를 정의한 속도로 정의한다.
                        twist.angular.z = 0.0        # z축 각속도를 0.0으로 정의한다.
                        right_wall_closest = True
            distances.clear()
            self._cmd_pub.publish(twist)        # 위에서 정의한 twist 메세지를 publish한다.


def main():     # 메인 구동문이다.
    rospy.init_node('ROS_HW5_obstacle')     # ROS 노드 'ROS_HW5_obstacle'을 초기화한다.
    try:        # 예외를 처리하기 위한 구문이다.
        obstacle = Obstacle()               # Obstacle 생성자를 호출한다.
    except rospy.ROSInterruptException:     # 예외가 발생하면, except 구문이 실행된다.
        pass    # 예외 처리를 하지 않고, 넘어가도록 하는 예약어이다.
    rospy.spin()

if __name__ == '__main__':      # 다른 코드에서 import되었을 시에는 실행되지 않고, 이 코드에서만 실행할 수 있도록 한다.
    main()      # main 문을 구동한다.
