import rospy        # rospy를 import하여 ROS 기반에서 파이썬을 사용가능하게 한다.
import math       # 수학공식을 사용하기 위해 math를 import 한다.
import time
from math import pi 
from sensor_msgs.msg import LaserScan       # lidar 센서 데이터를 subscribe하기 위해 메세지 형식과 패키지를 import한다.
from geometry_msgs.msg import Twist

WALL_PERCEPTION = 0.4   # 벽을 인식하는 거리를 1.0으로 정의한다.
LINEAR_VEL = 0.05                   # 선형 속도를 0.22m/s로 정의하는 구간으로, linear.x에 담겨 publish될 수치이다.
ANGULAR_VEL = 0.1
FORNT_NUM = 0
LEFT_NUM = 59                       # 59 90
RIGHT_NUM = 176                     # 176 270
BACK_NUM = 118                      # 118 180
RIGHT_NUM_1 = 166                   # 166 255
RIGHT_NUM_2 = 186                   # 186 285


class Obstacle():
    def __init__(self):     # obstacle class를 정의한다.
        self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)     # publisher를 정의해주고, 토픽명, 메세지 타입, 큐사이즈를 설정한다.
        self.obstacle()     # 생성자 함수를 호출한다.
        
    def get_scan(self):      # lidar data에서 direction에 따라 scan filter에 담을 데이터를 저장하고, 반환해주는 함수이다.
        scan = rospy.wait_for_message('scan', LaserScan)    # subscriber를 설정해주는 구간으로, 토픽명과 메세지 타입을 설정한다.
        scan_filter = []    # 빈 행렬을 정의한다.
        scan_filter.extend(scan.ranges)  # scan_filter 행렬 끝에 scan 행렬의 0번에 해당하는 원소를 추가한다.

        for i in range(len(scan_filter)):       # scan_filter의 원소 개수만큼 i를 1씩 증가하여 아래의 구문을 반복 실행한다.  
            if scan_filter[i] == float('Inf'):  # 만약, 센서값이 infinity일 경우, 아래의 구문을 실행한다.
               scan_filter[i] = 3.5             # 해당 센서값을 최대값 3.5m로 설정한다.
            elif math.isnan(scan_filter[i]):    # 만약, 센서값이 none 값일 경우, 아래의 구문을 실행한다.
               scan_filter[i] = 0               # 해당 센서값을 최소값 0m로 설정한다.

        return scan_filter      # scan_filter 행렬을 반환한다.
    
    def pub_cmd(self, Linear, Angle):
        twist = Twist()
        twist.linear.x = Linear      # x축 선형 속도를 정의한 속도로 정의한다.
        twist.angular.z = Angle      # z축 각속도를 0.0으로 정의한다.
        self._cmd_pub.publish(twist)        # 위에서 정의한 twist 메세지를 publish한다.

    def obstacle(self):         # lidar 센서값(물체와의 거리)으로 판단하고 행동하는 역할을 수행하는 함수이다.
        right_wall_closest = True
        right_wall_find = False         # 현재 turtlebot의 움직임 상태를 나타내는 변수로, 현재 움직임이 있다는 True로 정의한다.
        right_turn = 0
        left_turn = 0
        distances = []

        while not rospy.is_shutdown():                      # ROS가 구동하는 동안 무한으로 구동하는 반복문이다.
            distances.extend(self.get_scan())
            rospy.loginfo("\n\n                front : %f\n\nleft: %f                    right: %f\n\n                back  : %f\n",distances[FORNT_NUM], distances[LEFT_NUM], distances[RIGHT_NUM], distances[BACK_NUM])
            rospy.loginfo("\nclosest: %s, find: %s Rturn: %d Lturn: %d", right_wall_closest, right_wall_find, right_turn, left_turn)
            
            if (right_wall_closest):
                if (right_wall_find):
                    if distances[RIGHT_NUM_2] > WALL_PERCEPTION+1:
                        self.pub_cmd(LINEAR_VEL,(distances[RIGHT_NUM_1]-distances[RIGHT_NUM_2])*0.2)
                        right_turn += 1
                    elif distances[0] > WALL_PERCEPTION:
                        self.pub_cmd(LINEAR_VEL,(distances[RIGHT_NUM_1]-distances[RIGHT_NUM_2])*2.0+(WALL_PERCEPTION-distances[RIGHT_NUM])*0.5)
                    else:
                        self.pub_cmd(0.0,ANGULAR_VEL)
                        time.sleep(3)
                        right_wall_find = False
                else:
                    if distances[RIGHT_NUM_2] <= distances[RIGHT_NUM_1]:
                        self.pub_cmd(0.0,ANGULAR_VEL)
                    else:
                        self.pub_cmd(0.0,0.0)
                        right_wall_find = True
                        left_turn += 1
            else:
                if distances[FORNT_NUM] > WALL_PERCEPTION:
                    self.pub_cmd(LINEAR_VEL,0.0)
                else:
                    self.pub_cmd(0.0,ANGULAR_VEL)
                    right_wall_closest = True
            distances.clear()

def main():     # 메인 구동문이다.
    rospy.init_node('ROS_HW8_right_hand_method')     # ROS 노드 'ROS_HW5_obstacle'을 초기화한다.
    try:        # 예외를 처리하기 위한 구문이다.
        obstacle = Obstacle()               # Obstacle 생성자를 호출한다.
    except rospy.ROSInterruptException:     # 예외가 발생하면, except 구문이 실행된다.
        pass    # 예외 처리를 하지 않고, 넘어가도록 하는 예약어이다.

if __name__ == '__main__':      # 다른 코드에서 import되었을 시에는 실행되지 않고, 이 코드에서만 실행할 수 있도록 한다.
    main()      # main 문을 구동한다.




# #!/usr/bin/env python
# #################################################################################
# # Copyright 2018 ROBOTIS CO., LTD.
# #
# # Licensed under the Apache License, Version 2.0 (the "License");
# # you may not use this file except in compliance with the License.
# # You may obtain a copy of the License at
# #
# #     http://www.apache.org/licenses/LICENSE-2.0
# #
# # Unless required by applicable law or agreed to in writing, software
# # distributed under the License is distributed on an "AS IS" BASIS,
# # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# # See the License for the specific language governing permissions and
# # limitations under the License.
# #################################################################################

# # Authors: Gilbert #

import rospy
import math
from sensor_msgs.msg import LaserScan
from geometry_msgs.msg import Twist

ANGULAR_VEL = 0.5
LINEAR_VEL = 0.15
STOP_DISTANCE = 0.5
LIDAR_ERROR = 0.05
SAFE_STOP_DISTANCE = STOP_DISTANCE + LIDAR_ERROR # 0.45m
ANGULAR_STOP_DISTANCE = 0.25
class Obstacle():
    def __init__(self):
        self._cmd_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
        self.obstacle()
       
    def get_scan(self):
        scan = rospy.wait_for_message('scan', LaserScan)
        scan_filter = []
       
        samples = len(scan.ranges)  # The number of samples is defined in
                                    # turtlebot3_<model>.gazebo.xacro file,
                                    # the default is 360.
        samples_view = 4            # 1 <= samples_view <= samples
       
        if samples_view > samples:
            samples_view = samples

        if samples_view is 1:
             scan_filter.append(scan.ranges[0])
        
        if samples_view is 4:
            scan_filter.append(scan.ranges[0]) #front
            scan_filter.append(scan.ranges[59]) #left
            scan_filter.append(scan.ranges[118]) #back
            scan_filter.append(scan.ranges[176]) #right
            # scan_filter.append(scan.ranges[44]) #left front
            # scan_filter.append(scan.ranges[134]) #left back
            # scan_filter.append(scan.ranges[224]) #right front
            # scan_filter.append(scan.ranges[314]) #right back
        
        else:
            left_lidar_samples_ranges = -(samples_view//2 + samples_view % 2)
            right_lidar_samples_ranges = samples_view//2
           
            left_lidar_samples = scan.ranges[left_lidar_samples_ranges:]
            right_lidar_samples = scan.ranges[:right_lidar_samples_ranges]
            scan_filter.extend(left_lidar_samples + right_lidar_samples)

        for i in range(samples_view):
            if scan_filter[i] == float('Inf'):
                scan_filter[i] = 3.5
            if math.isnan(scan_filter[i]):
                scan_filter[i] = 0
       
        return scan_filter

    def obstacle(self):
        twist = Twist()
        turtlebot_moving = True

        while not rospy.is_shutdown():
            lidar_distances = self.get_scan()
            front_distance = lidar_distances[0] 
            left_distance = lidar_distances[1]
            back_distance = lidar_distances[2]
            right_distance = lidar_distances[3]
            # left_front_distance = lidar_distances[4] 
            # left_back_distance = lidar_distances[5] 
            # right_front_distance = lidar_distances[6] 
            # right_back_distance = lidar_distances[7]             
            if front_distance < SAFE_STOP_DISTANCE:
                if turtlebot_moving:
                    twist.linear.x = 0.0
                    twist.angular.z = 0.0
                    self._cmd_pub.publish(twist)
                    turtlebot_moving = False
                    rospy.loginfo('Stop!')
                    if left_distance > right_distance: #turn left if leftward site is exit
                        twist.linear.x = 0.0
                        twist.angular.z = ANGULAR_VEL
                        self._cmd_pub.publish(twist)
                        turtlebot_moving = True
                        rospy.sleep(0.5)
                        twist.linear.x = LINEAR_VEL
                        twist.angular.z = 0
                        self._cmd_pub.publish(twist)
                        turtlebot_moving = True     
                    if right_distance > left_distance: #turn right if rightward site is exit
                        twist.linear.x = 0.0
                        twist.angular.z = -ANGULAR_VEL
                        self._cmd_pub.publish(twist)
                        turtlebot_moving = True
                        rospy.sleep(0.5)
                        twist.linear.x = LINEAR_VEL
                        twist.angular.z = 0
                        self._cmd_pub.publish(twist)
                        turtlebot_moving = True                                                          
            # if (front_distance < 1) and (left_distance < 1) and (right_distance < 1):
            #     if turtlebot_moving:
            #         twist.linear.x = 0.0
            #         twist.angular.z = 0.0
            #         self._cmd_pub.publish(twist)
            #         turtlebot_moving = False
            #         rospy.loginfo('Goal!!!')            
            else:
                twist.linear.x = LINEAR_VEL
                twist.angular.z = 0.0
                self._cmd_pub.publish(twist)
                turtlebot_moving = True
                if right_distance < ANGULAR_STOP_DISTANCE:
                    rospy.loginfo('too close to the right wall!!')
                    twist.linear.x = 0.0
                    twist.angular.z = 0.07
                    self._cmd_pub.publish(twist)
                    turtlebot_moving = True
                    rospy.sleep(1)
                    twist.linear.x = LINEAR_VEL
                    twist.angular.z = 0
                    self._cmd_pub.publish(twist)
                    turtlebot_moving = True                         
                    # if right_front_distance == right_back_distance:
                    #     twist.linear.x = LINEAR_VEL
                    #     twist.angular.z = 0.0
                    #     self._cmd_pub.publish(twist)
                    #     turtlebot_moving = True
                if left_distance < ANGULAR_STOP_DISTANCE:
                    rospy.loginfo('too close to the left wall!!')
                    twist.linear.x = 0.0
                    twist.angular.z = -0.07
                    self._cmd_pub.publish(twist)
                    turtlebot_moving = True
                    rospy.sleep(1)
                    twist.linear.x = LINEAR_VEL
                    twist.angular.z = 0
                    self._cmd_pub.publish(twist)
                    turtlebot_moving = True                          
                    # if left_front_distance == left_back_distance:
                    #     twist.linear.x = LINEAR_VEL
                    #     twist.angular.z = 0.0
                    #     self._cmd_pub.publish(twist)
                    #     turtlebot_moving = True    
                # if (front_distance == SAFE_STOP_DISTANCE) and (left_distance < 8*SAFE_STOP_DISTANCE) and (back_distance < 8*SAFE_STOP_DISTANCE):
                #     if turtlebot_moving:
                #         twist.linear.x = 0.0
                #         twist.angular.z = 0.0
                #         self._cmd_pub.publish(twist)
                #         turtlebot_moving = False
                #         rospy.loginfo('!!Goal!!')                                              
                rospy.loginfo('Forward distance of the obstacle : %f', front_distance)
                rospy.loginfo('Leftward distancce of the obstacle : %f', left_distance)
                rospy.loginfo('Rightward distance of the obstacle : %f', right_distance)
                rospy.loginfo('Backward distance of the obstacle : %f', back_distance)
                rospy.loginfo('---------------------------------------------------')

def main():
    rospy.init_node('obstacle')
    try:
        obstacle = Obstacle()
    except rospy.ROSInterruptException:
        pass

if __name__ == '__main__':
    main()



