#!/usr/bin/env python
#################################################################################
# Copyright 2018 ROBOTIS CO., LTD.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#################################################################################

# Authors: Gilbert #

import rospy
import math
import time
from math import pi 
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import Odometry
from geometry_msgs.msg import Twist

LINEAR_VEL = 0.22
STOP_DISTANCE = 0.65
LIDAR_ERROR = 0.05
SPEED_X=0.2
SAFE_STOP_DISTANCE = STOP_DISTANCE + LIDAR_ERROR

class Obstacle():
    

    def __init__(self):
        self.obstacle()

        
    def get_scan_front(self):
        scan = rospy.wait_for_message('scan', LaserScan) # scan 토픽 수신 및 메시지 타입: Laser scan 
        #scan_filter=[]
        scan_filter_front = []
       
        samples = len(scan.ranges)  # The number of samples is defined in 
                                    # turtlebot3_<model>.gazebo.xacro file,
                                    # the default is 360.
        samples_view =    2        # 1 <= samples_view <= samples
        
        front_lidar_samples = scan.ranges[0:2]

        scan_filter_front.extend(front_lidar_samples)

        for i in range(samples_view):
            if scan_filter_front[i] == float('Inf'):
                scan_filter_front[i] = 3.5
            elif math.isnan(scan_filter_front[i]):
                scan_filter_front[i] = 0

               
        return scan_filter_front
    
    def get_scan_left(self):
        scan = rospy.wait_for_message('scan', LaserScan) # scan 토픽 수신 및 메시지 타입: Laser scan 
        #scan_filter=[]

        scan_filter_left = []
       
        samples = len(scan.ranges)  # The number of samples is defined in 
                                    # turtlebot3_<model>.gazebo.xacro file,
                                    # the default is 360.
        samples_view =   3        # 1 <= samples_view <= samples


        left_lidar_samples = scan.ranges[89:92]

        scan_filter_left.extend(left_lidar_samples)


            
        for i in range(samples_view):
          
            if scan_filter_left[i] == float('Inf'):
                scan_filter_left[i] = 3.5
            elif math.isnan(scan_filter_left[i]):
                scan_filter_left[i] = 0
               
        return scan_filter_left
    
    def get_scan_right(self):
        scan = rospy.wait_for_message('scan', LaserScan) # scan 토픽 수신 및 메시지 타입: Laser scan 
        #scan_filter=[]

        scan_filter_right = []

       
        samples = len(scan.ranges)  # The number of samples is defined in 
                                    # turtlebot3_<model>.gazebo.xacro file,
                                   # the default is 360.
        samples_view =    3       # 1 <= samples_view <= samples



        right_lidar_samples = scan.ranges[-92:-89]

        scan_filter_right.extend(right_lidar_samples)


            
        for i in range(samples_view):
          
            if scan_filter_right[i] == float('Inf'):
                scan_filter_right[i] = 3.5

            elif math.isnan(scan_filter_right[i]):
                scan_filter_right[i] = 0


               
        return scan_filter_right   


        

    def get_scan_back(self):
        scan = rospy.wait_for_message('scan', LaserScan) # scan 토픽 수신 및 메시지 타입: Laser scan 
        #scan_filter=[]

        scan_filter_back = []
       
        samples = len(scan.ranges)  # The number of samples is defined in 
                                    # turtlebot3_<model>.gazebo.xacro file,
                                    # the default is 360.
        samples_view =    2        # 1 <= samples_view <= samples


        back_lidar_samples = scan.ranges[180:182]


        scan_filter_back.extend(back_lidar_samples)

            
        for i in range(samples_view):

            if scan_filter_back[i] == float('Inf'):
                scan_filter_back[i] = 3.5

            elif math.isnan(scan_filter_back[i]):
                scan_filter_back[i] = 0

               
        return scan_filter_back   
    def euler_from_quaternion(self,x, y, z, w):
        """
        Convert a quaternion into euler angles (roll, pitch, yaw)
        roll is rotation around x in radians (counterclockwise)
        pitch is rotation around y in radians (counterclockwise)
        yaw is rotation around z in radians (counterclockwise)
        """
        t0 = +2.0 * (w * x + y * z)
        t1 = +1.0 - 2.0 * (x * x + y * y)
        roll_x = math.atan2(t0, t1)
     
        t2 = +2.0 * (w * y - z * x)
        t2 = +1.0 if t2 > +1.0 else t2
        t2 = -1.0 if t2 < -1.0 else t2
        pitch_y = math.asin(t2)
     
        t3 = +2.0 * (w * z + x * y)
        t4 = +1.0 - 2.0 * (y * y + z * z)
        yaw_z = math.atan2(t3, t4)
     
        return yaw_z # in radians
 
    def turn_angle(self, angle):
        odom_in = rospy.wait_for_message('odom',Odometry)
        # Imu in 값은 밖에서 넣어주기
        robot_heading=self.euler_from_quaternion(odom_in.pose.pose.orientation.x,odom_in.pose.pose.orientation.y,odom_in.pose.pose.orientation.z,odom_in.pose.pose.orientation.w)
        vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
        twist=Twist()
        twist.linear.z=0
        print(str(robot_heading/pi*180))
        current_heading = robot_heading
        if angle==180:
            angle=angle-2
            while robot_heading<(angle/(180)*pi):
                print("robot_heading"+str(robot_heading)+"angle"+str((angle/(180)*pi)))
                odom_in = rospy.wait_for_message('odom',Odometry)
                robot_heading=self.euler_from_quaternion(odom_in.pose.pose.orientation.x,odom_in.pose.pose.orientation.y,odom_in.pose.pose.orientation.z,odom_in.pose.pose.orientation.w)
                twist.angular.z=0.3
                vel_pub.publish(twist)
            twist.angular.z=0
        elif angle==-180:
            angle=180-2
            while robot_heading<(angle/(180)*pi):
                print("robot_heading"+str(robot_heading)+"angle"+str((angle/(180)*pi)))
                odom_in = rospy.wait_for_message('odom',Odometry)
                robot_heading=self.euler_from_quaternion(odom_in.pose.pose.orientation.x,odom_in.pose.pose.orientation.y,odom_in.pose.pose.orientation.z,odom_in.pose.pose.orientation.w)
                twist.angular.z=0.3
                vel_pub.publish(twist)
            twist.angular.z=0
        elif (angle-(robot_heading/pi*180))>0:
            while robot_heading<(angle/(180)*pi):
                odom_in = rospy.wait_for_message('odom',Odometry)
                robot_heading=self.euler_from_quaternion(odom_in.pose.pose.orientation.x,odom_in.pose.pose.orientation.y,odom_in.pose.pose.orientation.z,odom_in.pose.pose.orientation.w)
                twist.angular.z=0.3
                vel_pub.publish(twist)
            twist.angular.z=0
        elif (angle-(robot_heading/pi*180))<0:
            while robot_heading>(angle/(180)*pi):
                odom_in = rospy.wait_for_message('odom',Odometry)
                robot_heading=self.euler_from_quaternion(odom_in.pose.pose.orientation.x,odom_in.pose.pose.orientation.y,odom_in.pose.pose.orientation.z,odom_in.pose.pose.orientation.w)
                twist.angular.z=-0.3
                vel_pub.publish(twist)
            twist.angular.z=0
        
        current_heading = robot_heading
        print("after while"+str(robot_heading/pi*180))
        vel_pub.publish(twist)
        


    def movingFoward(self,speed,SAFE_STOP_DISTANCE,target_angle):
        vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
        twist=Twist()
        front_lidar_distances = self.get_scan_front()
        front_min_distance = min(front_lidar_distances)
        count=0
        while front_min_distance>(SAFE_STOP_DISTANCE-0.15):
            front_lidar_distances = self.get_scan_front()
            front_min_distance = min(front_lidar_distances)
            twist.linear.x=speed
            vel_pub.publish(twist)
            count+=1
            print(count)
            if count %30 == 0:
                self.turn_angle(target_angle)
                time.sleep(1)
            
        twist.linear.x=0
        twist.angular.z=0
        vel_pub.publish(twist)

         
    
    def obstacle(self):
        turtlebot_moving = True
        vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
        twist=Twist()
        target_angle=0
        while not rospy.is_shutdown():
            self.turn_angle(target_angle)
            front_lidar_distances = self.get_scan_front()
            front_min_distance = min(front_lidar_distances)
            left_lidar_distances = self.get_scan_left()
            left_min_distance = min(left_lidar_distances)
            right_lidar_distances = self.get_scan_right()
            right_min_distance = min(right_lidar_distances)
            back_lidar_distances = self.get_scan_back()
            back_min_distance = min(back_lidar_distances)

            #rospy.loginfo("front:"+str(front_min_distance))
            #rospy.loginfo("left:"+str(left_min_distance))
            #rospy.loginfo("right:"+str(right_min_distance))
            #rospy.loginfo("back:"+str(back_min_distance))

            if front_min_distance < SAFE_STOP_DISTANCE:
                front=0
            else :
                front=1
            if left_min_distance < SAFE_STOP_DISTANCE:
                left=0
            else :
                left=1
            if right_min_distance < SAFE_STOP_DISTANCE:
                right=0
            else :
                right=1
            if back_min_distance < SAFE_STOP_DISTANCE:
                back=0      
            else :
                back=1
            
            
            time.sleep(1.5)
            if front==1:
                print("front and static="+str(target_angle))
                self.movingFoward(SPEED_X,SAFE_STOP_DISTANCE,target_angle)
            elif left==1:
                
                target_angle=90+target_angle
                if target_angle>180:
                    target_angle=target_angle-360
                if target_angle<=-180:
                    target_angle=target_angle+360
                print("target angle="+str(target_angle))
                self.turn_angle(target_angle)

            elif right==1:
                
                target_angle=-90+target_angle
                if target_angle>180:
                    target_angle=target_angle-360
                if target_angle<=-180:
                    target_angle=target_angle+360 
                print("target angle="+str(target_angle))               
                self.turn_angle(target_angle)
                
                #Odom_sub = rospy.Subscriber ('/odom', Odometry)
            elif back==1:
                
                target_angle=180+target_angle
                if target_angle>180:
                    target_angle=target_angle-360
                if target_angle<=-180:
                    target_angle=target_angle+360
                print("target angle="+str(target_angle))
                self.turn_angle(target_angle)
                
            

def main():
    rospy.init_node('find_obstacle')
    try:
        obstacle = Obstacle()
    except rospy.ROSInterruptException:
        pass

if __name__ == '__main__':
    main()
